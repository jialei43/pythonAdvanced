"""
Python 解释器在启动时，会提前创建一批常用的小整数对象，默认范围是：-5 ~ 256
这些整数对象：
    只创建一次
    放在一个缓存池里
    以后用到直接拿来用
所以 a=100,b=100指向同一内存地址：
a 和 b 指向同一个内存地址，是因为 Python 对小整数做了缓存（整数驻留）
"""
a = 100
b = 100
# 4338200552
print(id(a))
# 4338200552
print(id(b))

# 如果数据在 < -5 或者大于 256，而你看到的大整数相同 id，来自“编译期常量折叠与复用”
"""
一句话结论（先给答案）
a = 10000000 和 b = 10000000 的 id 一样，
不是运行期的小整数缓存，而是：
🔥 编译阶段的常量复用（constant folding / constant interning


在 编译成字节码 时：
10000000 是 字面量常量
编译器会把它放进 同一个 constants 表（co_consts）
两行代码引用的是 同一个常量对象

五、为什么 Python 要这么做？
1️⃣ 性能优化
少创建对象
少分配内存
提高执行速度
2️⃣ 安全
整数是 不可变对象
多个变量指向同一个值不会有副作用
"""
"""
六、⚠️ 为什么这个行为“不可靠”？
非常重要的一点：
常量复用是实现细节，不是语言规范
所以：
不同 Python 版本
不同解释器
不同运行环境（交互式 / 脚本）
结果可能不同
📌 永远不要依赖这个行为写逻辑

七、完整对比表（帮你彻底理清）
场景	                                    是否同一个对象	        原因
a = 100 / b = 100	                    ✅	                    小整数缓存（运行期）
a = 10000000 / b = 10000000	            ✅                      （可能）	编译期常量复用
a = int("10000000")	                    ❌	                    运行期创建
a = 10**7	                            ❌                      （通常）	运行期计算
a = 10000000; del a; b = 10000000	    ❓	                    内存复用
"""
a = 100000000000000
b = 100000000000000

# 4338200552
print(id(a))
# 4338200552
print(id(b))
